# Introducci√≥n al Testing

üß™ [Introducci√≥n al Testing con JEST ‚úÖ (Bootcamp FullStack) - midudev](https://www.youtube.com/watch?v=_DzBez4qMi0)

La forma m√°s simple de entender el testing es pensando que nos permitir√° comprobar el correcto funcionamiento de un m√©todo.

Es importante que los tests sean predecibles, que no dependan de factores externos de modo tal que siempre que los ejecute obtenga el mismo resultado.

A la hora de crear tests es importante hacerlos fallar pues quiz√°s nunca falle y eso lo convertir√≠a en un test in√∫til.

Supongamos que tenemos:

```javascript
const suma = (a,b) => {
  return a-b;
}
```

Si bien en este caso podemos darnos cuenta f√°cilmente qu√© est√° mal, en ocasiones ser√° mucho m√°s dif√≠cil notarlo. 

La importancia de los tests est√° no s√≥lo en saber si nuestro m√©todo funciona o no, sino que tambi√©n **nos permite documentar estos m√©todos** .

## Test en RunJS

Para testear este m√©todo de manera manual, podemos hacerlo en un entorno controlado utilizando **RunJS** que act√∫a como banco de pruebas o playground. 

Bastar√° con ingresar `suma(1,2) === 3` y nos aparecer√° `false` lo cual nos da la pauta de que no est√° funcionando correctamente.

Otra forma de plantearlo podr√≠a ser `if(suma(1,2)!==3) console.log('suma of 1 and 2 expected to be 3')` o bien tirando un error para hacerlo m√°s sem√°ntico `if(suma(1,2)!==3) new Error('suma of 1 and 3 expected to be 3')`

Sin embargo puede que para otras condiciones el m√©todo s√≠ funcione, por ejemplo si pusi√©ramos como argumentos 0 y 0 el `if(suma(0,0)!==0) new Error('suma of 0 and 0 expected to be 0')` no ser√≠a ejecutado ya que da el valor esperado.



## Test en Node

Para testear esto mismo tambi√©n manualmente pero directo en el proyecto de Express creamos una carpeta `tests ` y un archivo `suma.test.js`. 

> Tambi√©n podr√≠a ser `.spec.js`.

Haremos uso del m√©todo `console.assert()` con el cual aseveramos que una cosa dar√° cierto valor y en caso de que no se cumpla mostraremos un mensaje de error. Si lo que le pasamos como primer par√°metro es `false` saldr√° el error que le pasemos como segundo par√°metro.

```javascript
const suma = (a,b) => {
  return a-b
}

console.assert(
    suma(0,0)===3,
    'Suma of 0 and 0 expected to be 0'
)

console.assert(
    suma(1,2)===3,
    'Suma of 1 and 2 expected to be 3'
)
```



Luego para ejecutar este test 

```
node tests/suma.test.js
```

Nos aparecer√° ese mensaje de error s√≥lo en caso de que la aseveraci√≥n falle.



Lo ideal ser√≠a probar mas casos y eso podemos hacerlo empleando un array.

```javascript
const suma = (a,b) => {
  return a-b
}

const checks = [
	{ a: 0, b:0, result:0},
	{ a: 1, b:2, result:3},
	{ a: -3, b:3, result:0},
];

checks.forEach(check => {
	const {a,b,result} = check;
	console.assert(
    suma(a,b)===result,
    `Suma of ${a} and ${b} expected to be ${result}`
)
})

console.log(`${checks.length}` checks performed...);
```

Si bien podr√≠amos ampliar la informaci√≥n devuelta en el mensaje de error para aportar mas datos, esto no tiene sentido pues existen herramientas que se encargan de ejecutar una tanda de tests y entregarnos un error detallado que nos permita saber d√≥nde est√°n los fallos y solucionarlos.

Estas herramientas reciben el nombre de framework de testing que nos dar√°n una serie de funciones y un test runner con el cual ejecutamos los tests y obtenemos un reporte de cu√°ntos pasaron la prueba.
Los frameworks mas conocidos son **Jasmine**, **Mocha** y **Jest** 


# Jest 

Jest es un testing framework de JavaScript mantenido por Facebook. Inicialmente fue desarrollado para hacer testing en el navegador y luego evolucion√≥ siendo posible utilizarlo en servidor.

```
npm install jest -D
```

> Mocha y AVA son otras alternativas que al igual que Jest son frameworks de testing que podr√≠amos haber elegido.



Como vamos a probar un m√©todo en concreto vamos a desarrollar lo que se conoce como **test unitario**. Esto es as√≠ cuando tenemos una entrada y una salida y no produce **side effects**, ni llama a otras funciones.

```javascript
const palindrome = (string) => {
  if(typeof string === 'undefined') return;
  
  return string
    .split('')
    .reverse()
    .join('')
}

module.exports = {
  palindrome
}
```

## Configuraci√≥n Jest 

En `package.json` debemos modificar el script `"test"` de modo que quede de la siguiente forma:

```json
"scripts":{
	"test": "jest --verbose --silent"
}
```

> Con `--verbose` le indicamos que queremos que nos entregue la m√°xima informaci√≥n posible.
>
> Con `--silent` le indicamos que no queremos que nos muestre los `console.log()`.

Jest como dijimos anteriormente est√° pensado para trabajar por defecto en el cliente y viene con la capacidad de simular aspectos del DOM. Esto no s√≥lo no lo necesitamos sino que puede ser problem√°tico. Es por eso que en `package.json`  vamos a colocar:

```json
"jest":{
	"testEnvironment": "node"
}
```

> Otra opci√≥n ser√≠a colocarlo en `jest.config.js` pero lo ideal es tenerlo todo en un mismo lugar as√≠ es m√°s f√°cil de encontrar y con menos archivos.

> Es posible que en Windows experimentemos problemas si el nombre de la carpeta tiene espacios (por ejemplo si nuestro nombre de usuario los tiene).



### Jest con ESModules

Si queremos utilizar jest con import y export es probable que tengamos que configurar lo siguiente:

```bash
"test": "set NODE_OPTIONS=--experimental-vm-modules && jest"
```

En Linux directamente podremos ponerlo sin el `set` y sin el `&&`,  `NODE_OPTIONS=--experimental-vm-modules jest`



## Ejecuci√≥n de Tests

Si ejecutamos ahora `npm t` o `npm test` o `npm run test` veremos "No test found" y tambi√©n veremos el pattern usado por jest para encontrar los tests
`testMatch: **/__tests__/**/*.[jt]s?(x), **/?(*.)+(spec|test).[tj]s?(x)` Lo cual nos da una idea de que entre otras opciones los archivos terminados en `test.js` dentro de una carpeta `test` ser√°n considerados tests.



> Jest por defecto buscar√° todos los archivos que terminen en `.test.js`
>
> No es necesario importar `jest` ya que una vez que encuentra este archivo sabe que debe utilizar esas dependencias.

## Testing de Funciones Externas

En `lib.js` tenemos la funci√≥n `absolute()` :
```js
module.exports.absolute = function(number) {
  if (number > 0) return number; 
  if (number < 0) return -number; 
  return 0; 
}
```
El n√∫mero de unit tests debe ser mayor o igual de posibles caminos de ejecuci√≥n de manera tal que verifiquemos toda la l√≥gica. En este caso tenemos 3 caminos posibles.

El primer caso de testeo o primer execution path:
```js
const lib = require('../lib');
test('absolute - retornar >0 si entrada >0', () => {
	const result = lib.absolute(1);
	expect(result).toBe(1);
});
```

 `expect()` es una utility function y `toBe()` es una matcher function podemos ver la lista completa en:
 [https://jestjs.io/docs/en/using-matchers](https://jestjs.io/docs/en/using-matchers)

A la hora de testear n√∫meros contamos con los siguientes matchers: `toEqual()` (en este caso funciona de la misma manera que `toBe()`) , `toBeGreaterThan()`, `toBeGreaterThanOrEqual()`, `toBeLessThan()`, `toBeLessThanOrEqual()`. 
En caso de tener n√∫meros de punto flotante no podremos usar el matcher de *exact equality* `toEqual()` sino que usamos `toBeCloseTo()`

Completando el resto de los casos de testeo:
```js
const lib = require('../lib');
test('absolute - retornar >0 si entrada >0', () => {
	const result = lib.absolute(1);
	expect(result).toBe(1);
});
test('absolute - retornar >0 si entrada <0', () => {
	const result = lib.absolute(-1);
	expect(result).toBe(1);
});
test('absolute - retornar 0 si entrada 0', () => {
	const result = lib.absolute(0);
	expect(result).toBe(0);
});
```

Supongamos que en el √∫ltimo test en vez de `expect(result).toBe(0);`tuvieramos `expect(result).toBe(1);` el test fallar√≠a y podr√≠amos visualizar el valor esperado (1) y el valor recibido (0) junto con la l√≠nea donde se produjo la falla.


## Agrupando Tests
En la medida que el n√∫mero de tests aumenta es importante tenerlos organizados para que el mantenimiento sea simple.
La funci√≥n `describe()` nos permite agrupar los tests relacionados (con lo cual podremos simplificar el nombre de cada test) y tambi√©n podemos reemplazar `test()` por `it()` . 

Tambi√©n es posible anidar bloques `describe`.

> Si tuvi√©ramos todo escrito en ingl√©s ver√≠amos `it('should return >0 if input >0')` es decir que lo ver√≠amos como *plain english* "it should return..." 
```js
const lib = require('../lib');
describe('absolute', () => {
	it('deberia retornar >0 si entrada >0', () => {
		const result = lib.absolute(1);
		expect(result).toBe(1);
	});
	it('deberia retornar >0 si entrada <0', () => {
		const result = lib.absolute(-1);
		expect(result).toBe(1);
	});
	it('deberia retornar 0 si entrada 0', () => {
		const result = lib.absolute(0);
		expect(result).toBe(0);
	});
});
```
Los tests nos permiten hacer refactoring con la confianza de que si la nueva implementaci√≥n pasa todos los tests funcionar√°. Si no tuvieramos tests para esta funci√≥n, realizar cambios ser√≠a m√°s engorroso ya que tendr√≠amos que ejecutar la aplicaci√≥n y navegar hacia la parte de la aplicaci√≥n donde se usa la funci√≥n.



## Testing Strings
Trabajaremos con la funci√≥n `greet()` que recibe un nombre y entrega un string.
```js
module.exports.greet = function (name) {
	return 'Welcome ' + name;
};
```
Entonces para comprobar su funcionamiento creamos el siguiente test:
```js
describe('greet', () => {
	it('deberia retornar un mensaje', () => {
		const result = lib.greet('Juan');
		expect(result).toBe('Welcome Juan');
	});
});
```
Si bien el test pasar√°, un m√≠nimo cambio en el string de `greet()` por ejemplo `return 'Welcome ' + name + '!';` har√° que el test falle. 
Los tests no deben ser ni muy **espec√≠ficos** (se rompen f√°cilmente) ni muy **generales** (no brindar√°n confianza). Es por eso que a la hora de testear strings en vez de buscar exact equality podemos buscar ciertos patterns usando regular expressions y la funci√≥n `toMatch(regEx)`. 
Otra alternativa ser√≠a usar el matcher `toContain()`.

```js
describe('greet', () => {
	it('deberia retornar un mensaje', () => {
		const result = lib.greet('Juan');
		expect(result).toMatch(/Juan/);
	});
});
```

## Testing Arrays

Trabajaremos con la funci√≥n `getCurrencies()`:
```js
module.exports.getCurrencies = function () {
	return ['USD', 'AUD', 'EUR'];
};
```

```js
describe('getCurrencies', () => {
	it('deberia retornar las monedas aceptadas', () => {
		const result = lib.getCurrencies();
		//afirmaci√≥n muy general: retornar por ejemplo un n√∫mero pasar√≠a el test
		expect(result).toBeDefined();
		expect(result).not.toBe(null);

		//afirmaci√≥n muy espec√≠fica:
		//un simple ordenamiento del array puede romper el test
		expect(result[0]).toBe('USD');
		expect(result[1]).toBe('AUD');
		expect(result[2]).toBe('EUR');
		//el agregado de una nueva moneda romper√≠a le test
		expect(result.length).toBe(3);

		//Modo aceptable: con 3 assertions (o afirmaciones)
		expect(result).toContain('USD');
		expect(result).toContain('AUD');
		expect(result).toContain('EUR');

		//Modo ideal: m√°s compacto
		expect(result).toEqual(expect.arrayContaining(['EUR', 'USD', 'AUD']));

	});
});

```

`expect.arrayContaining(arrayEspecificado)` matchea si el array recibido contiene todos los elementos del array especificado. En caso de de que en un futuro agreguemos m√°s tipos de monedas seguir√° funcionando.


## Testing Objects
Trabajamos con la funci√≥n `getProduct()`

```js
module.exports.getProduct = function (productId) {
	return { id: productId, price: 10 };
};
```

```js

describe('getProduct', () => {
	it('deberia retornar el producto con el id entregado', () => {
		const result = lib.getProduct(1);

        //afirmaci√≥n muy espec√≠fica
        expect(result).toEqual({ id: 1, price: 10 });
        
        //afirmaciones correctas
		expect(result).toMatchObject({ id: 1, price: 10 });
		expect(result).toHaveProperty('id', 1);
	});
});

```

N√≥tese que no usamos `toBe()` ya que si pusi√©ramos `expect(result).toBe({id:1, price:10}` como se trata de dos objetos en distintas posiciones de memoria el test fallar√°, es por eso que debemos usar `toEqual()`.

Supongamos que `getProduct()` entrega varias propiedades adem√°s de `id` y `price`, en ese caso ya no puedo usar `expect(result).toEqual({ id: 1, price: 10 });` sino que tengo que cambiar `toEqual()` por `toMatchObject()`: `expect(result).toMatchObject({ id: 1, price: 10 });`
Una tercera opci√≥n es usando la funci√≥n `toHaveProperty(key,value)` tener presente que el *value* debe ser del tipo esperado en este caso `Number`.

Para chequear si una propiedad est√° presente en la respuesta podr√≠amos usar tambi√©n `expect(result.body.id).toBeDefined();`

## Testing Exceptions
Trabajamos con la funci√≥n `registerUser()` podemos ver que si el `username` es *falsy* (`0`, `false`, `empty string`, `null`, `undefined`, `NaN`) tiramos una excepci√≥n en caso contrario retorna un objeto con las propiedades `id` y `username`. Tenemos dos *execution paths* por lo que necesitamos por lo menos dos unit tests.
```js
module.exports.registerUser = function (username) {
	if (!username) throw new Error('Username is required.');

	return { id: new Date().getTime(), username: username };
};
```

Como las excepciones no son valores devueltos por la funci√≥n, no podemos almacenarlos en una variable como venimos haciendo hasta ahora sino que debemos hacer lo siguiente: `expect(callback).toThrow(); `
```js
it('deberia tirar excepcion', () => {
		expect(() => {lib.registerUser(0);}).toThrow();
});
```
Tenemos que repetir esto mismo para cada uno de los valores falsy.  Es por eso que creamos un array con los argumentos que queremos pasar y luego un loop.

Sin embargo existe algo llamado *single assertion principle* (algunos lo interpretan como un √∫nico llamado a `expect()` en cada test), nosotros en cambio interpretamos que en este caso si bien estamos llamando varias veces a `expect()` lo estamos haciendo con la misma l√≥gica (valores falsy). En este caso no habr√≠a mucha diferencia entre nuestra implementaci√≥n y hacer distintos tests, pero en ocasiones el test ser√° de muchas l√≠neas y no queremos tener todo ese c√≥digo repetido.

En cuanto al test para cuando el funcionamiento es correcto (happy path) y retorna un usuario, si bien colocamos dos expectations, afirmaciones o assertions con `expect()` (como en otras oportunidades ya hemos hecho) nuevamente ambos corresponden al mismo concepto l√≥gico.
```js
describe('registerUser', () => {
	it('deberia tirar excepcion', () => {
		const args = [null, undefined, NaN, '', 0, false];
		args.forEach((a) => {
			expect(() => {
				lib.registerUser(a);
			}).toThrow();
		});
	});
	it('deberia retornar un usuario', () => {
		const result = lib.registerUser('mosh');
		expect(result).toMatchObject({ username: 'mosh' });
		expect(result.id).toBeGreaterThan(0);
	});
});
```



## Testing Funci√≥n FizzBuzz 

Supongamos que tenemos en un archivo llamado `exercise1.js` la siguiente funci√≥n `FizzBuzz`

```js

module.exports.fizzBuzz = function(input) { 
  if (typeof input !== 'number') 
    throw new Error('Input should be a number.');
    
  if ((input % 3 === 0) && (input % 5) === 0)
    return 'FizzBuzz';

  if (input % 3 === 0)
    return 'Fizz';

  if (input % 5 === 0)
    return 'Buzz'; 

  return input; 
}
```
```js
const exercise1 = require('../exercise1');

describe('FizzBuzz', () => {
	it('deberia tirar un error si la entrada no es un n√∫mero', () => {
		expect(() => {
			exercise1.fizzBuzz('a');
		}).toThrow();
		expect(() => {
			exercise1.fizzBuzz(null);
		}).toThrow();
		expect(() => {
			exercise1.fizzBuzz(undefined);
		}).toThrow();
		expect(() => {
			exercise1.fizzBuzz({});
		}).toThrow();
	});
	it('deberia retornar FizzBuzz si es m√∫ltiplo de 3 y 5', () => {
		const result = exercise1.fizzBuzz(15);
		expect(result).toBe('FizzBuzz');
	});
	it('deberia retornar FizzBuzz si es m√∫ltiplo de 3 y no de 5', () => {
		const result = exercise1.fizzBuzz(3);
		expect(result).toBe('Fizz');
	});
	it('deberia retornar FizzBuzz si es m√∫ltiplo de 5 y no de 3', () => {
		const result = exercise1.fizzBuzz(5);
		expect(result).toBe('Buzz');
	});
	it('deberia retornar el n√∫mero si no es divisible por 3 ni por 5', () => {
		const result = exercise1.fizzBuzz(1);
		expect(result).toBe(1);
	});
});
```
## Simple Mock Functions
Hasta ahora usamos funciones sin dependencias en funciones externas, sin embargo esto no es as√≠ en la funci√≥n `applyDiscount()` que podemos ver a continuaci√≥n:

```js
const db = require('./db');

module.exports.applyDiscount = function (order) {
	const customer = db.getCustomerSync(order.customerId);

	if (customer.points > 10) order.totalPrice *= 0.9;
};
```

En `db.js` simulamos un llamado a MongoDB
```js
module.exports.getCustomerSync = function(id) { 
  console.log('Reading a customer from MongoDB...');
  return { id: id, points: 11 };
}
```
En los unit tests no debemos hablar con external resources, sino ser√≠a un integration test. El objetivo central de los unit tests es desacoplar los recursos externos pues estos pueden no estar disponibles a la hora de ejecutar los unit tests. Supongamos que en vez de obtener el customer de una db lo obtenemos de un servicio http remoto, en ese caso tendr√≠amos que tener ese servicio corriendo para ejecutar los c√≥digos o el test fallar√≠a.

Veremos a continuaci√≥n como aplicar unit tests a una funci√≥n que directa o indirectamente habla con external resources. Debemos remplazar la implementaci√≥n de `db.getCustomerSync()` por una fake o mock implementation que tome y entregue los mismos datos, pero que no hable con una db o un servicio http remoto. 

```js
const db = require('../db');
describe('applyDiscount', () => {
	it('deberia aplicar descuento si la cantidad de puntos es mayor a 10', () => {
		db.getCustomerSync = (customerId) => {
			console.log('Leyendo customer de mock function...');
			return { id: customerId, points: 20};
		};

		const order = { customerId: 1, totalPrice: 10 };
		lib.applyDiscount(order);
		expect(order.totalPrice).toBe(9);
	});
});
```
Importamos el m√≥dulo db `const db = require('../db');` y luego dentro del test remplazamos la funci√≥n `db.getCustomerSync()` por una versi√≥n falsa que no habla a una db.
Al agregar esta funci√≥n veremos que deja de aparecer el mensaje `'Reading a customer from MongoDB...'` y en cambio vemos `'Leyendo customer de mock function...'`

## Test de palindrome

En primer lugar creamos el archivo `palindrome.test.js` en la carpeta `test`.



```js
test('Primer Test', () => {

});
```
Si ejecutamos ahora `npm t` veremos que el test pasa la prueba exitosamente
```bash
‚úÖ palindrome of juaneme8
```

Mientras que si generamos un error:
```js
test('Primer Test', () => {
	throw new Error('Algo fall√≥');
});
```
Al ejecutar el test veremos qu√© archivo de tests fall√≥, en particular qu√© test y tambi√©n en qu√© l√≠nea de c√≥digo.
```bash
‚úÖ palindrome of juaneme8
```



```javascript
const {palindrome} = require('../utils/for_testing')

test ('palindrome of juaneme8', ()=> {
	const result = palindrome('juaneme8');
	
	expect(result).toBe('8emenauj');
})
test ('palindrome of empty string', ()=> {
	const result = palindrome('');
	
	expect(result).toBe('');
})
test ('palindrome of undefined', ()=> {
	const result = palindrome();
	
	expect(result).toBeUndefined();
})
```

Con `test()` estamos creando un test y lo que est√° dentro del *callback* ser√° lo que ejecutar√° para comprobar dicha prueba.

Podemos de un vistazo utilizar los tests como documentaci√≥n del m√©todo. En este caso estaremos analizando las condiciones de borde o *corner cases* como ser qu√© sucede si llamamos al m√©todo con un string vac√≠o, `undefined`, etc.



En la terminal veremos una salida similar a la siguiente:

```
‚úÖ palindrome of juaneme8
‚úÖ palindrome of empty string
‚úÖ palindrome of undefined
```

Cuando tengamos m√°s de un archivo nos convendr√° agrupar los tests de cada uno de ellos y esto lo hacemos con el m√©todo `describe()`

```js
const {palindrome} = require('../utils/for_testing')

describe('palindrome', ()=> {
    test ('of juaneme8', ()=> {
        const result = palindrome('juaneme8');

        expect(result).toBe('8emenauj');
    })
    test ('of empty string', ()=> {
        const result = palindrome('');

        expect(result).toBe('');
    })
    test ('of undefined', ()=> {
        const result = palindrome();

        expect(result).toBeUndefined();
    })
})
```

Ahora en cambio veremos

```
palindrome
    ‚úÖ of juaneme8
    ‚úÖ of empty string
    ‚úÖ of undefined
```



## M√©todos Jest

Podemos ver la lista completa de m√©todos en la [documentaci√≥n](https://jestjs.io/docs/expect).

* `toBe()`
* `toBeNull()`
* `toBeUndefined()`
* `toEqual()`


## Configuraci√≥n ESLINT

Para evitar que el linter nos marque como errores el uso de `test()` y `expect() ` debemos modificar el la configuraci√≥n de eslint.

Es posible que ESLint lo tengamos configurado en `package.json` y en ese caso debemos modificar el objeto `eslintConfig` **agregando** lo siguiente:

```json
"eslintConfig":{
	"env":{
		"jest": true,
	}
}
```



Si tenemos un archivo `.eslintrc.js` debemos agregar `jest: true` dentro de:

```
module.exports = {
	env:{
		...
		...,
		jest: true
	}
}
```



## Testing API Rest

[üî¥ Testing de Backend con Express usando Jest y Supertest - midudev](https://www.youtube.com/watch?v=_xxVJdGNMrs)



Como sabemos existen distintos tipos de tests: unitarios, de integraci√≥n y *end to end*. 

En este caso queremos testear una API REST y lo m√°s importante es testear a los endpoints y el efecto que generan en la base de datos por lo tanto decimos que son **tests de integraci√≥n** (incluso se podr√≠a decir que son *e2e*). No utilizamos **tests unitarios** pues estos nos servir√≠an para testear de manera aislada un m√©todo. Utilizando el paquete supertest haremos las peticiones http y luego jest se encargar√° de evaluar los resultados.



## Variables Entorno y Scripts

A la hora de testear el backend lo primero que debemos hacer es modificar el archivo `package.json` en particular los scripts para asegurarnos cargar con un valor distinto la variable de entorno `NODE_ENV` seg√∫n ejecutemos estemos en *development* `npm run dev`, *production* `npm start` o *testing* `npm test`.

Si estamos utilizando Windows tendremos que utilizar el paquete `cross-env`.

```json
{ 
    "scripts": {
        "dev": "cross-env NODE_ENV=development nodemon index.js",
        "start": "cross-env NODE_ENV=production node index.js",
        "test": "cross-env NODE_ENV=test jest --verbose --silent"
	},
}
```

> Tambi√©n podr√≠amos pasarle un puerto especial para que utilice a la hora de correr los tests en lugar del definido en el archivo `.env` as√≠ evitamos colisiones por tener abierto el mismo puerto.

```json
"test": "cross-env NODE_ENV=test PORT=1234 jest --verbose --detectOpenHandles",
```



Luego en funci√≥n del valor de `NODE_ENV` ser√° que usaremos uno u otro connection string para conectarnos a la base de datos de producci√≥n o a la de pruebas.

```javascript
const { NODE_ENV,MONGO_DB_URI,MONGO_DB_URI_TEST} = process.env;
const connectionString = NODE_ENV === 'test'
? MONGO_DB_URI_TEST
: MONGO_DB_URI;
```

> Las variables de entorno `MONGO_DB_URI` y `MONGO_DB_URI_TEST` debemos definirlas en un archivo `.env` . Para acceder a esos valores mediante `process.env` debemos tener instalado `dotenv` y colocar en `index.js` `require('dotenv').config()` en la parte de arriba. Si lo colocamos debajo de la conexi√≥n a Mongo `require('./mongo')` no obtendremos el connection string.
>
> El hecho de crear una base de datos para testing no es buena pr√°ctica y al estudiar CI/CD veremos que lo m√°s conveniente ser√≠a mockearla.


## Test de Endpoints
Como nuestro prop√≥sito es testear los endpoints, utilizaremos la biblioteca Supertest para acceder a ellos. Esta herramienta envuelve nuestro servicio de backend y nos permite testear los endponts. 

```bash
npm install supertest -D
```

Creamos un directorio `test` y en el un archivo `notes.test.js` . En esta prueba buscamos verificar que las notas de una api sean devueltas en JSON. 



## Peticiones `GET`

Cuando devolvemos una nota entregamos un status code `200` que significa **OK**.

Debemos tener presente que se trata de una operaci√≥n as√≠ncrona por lo que debemos esperar a que est√© el resultado disponible. Esto lo hacemos con `async` y `await`.

```js
const supertest = require('supertest');
const {app} = require('../index');

const api = supertest(app);

test('the result should be a json', async () => {
    await api
        .get('/api/notes')
        .expect(200)
        .expect('Content-Type', /application\/json/);
});
```



> Como debemos exportar `app` para luego importarlo en el test, quiz√°s nos convenga trabajar con `app.js` con `module.exports = { app };` y con `index.js` que tambi√©n importar√° este valor y ejecuta el `app.listen()`
>
> Notar que usamos una RegEx porque podemos recibir `application/json; charset=utf-8` Sino podr√≠amos haber puesto `expect(res.header['content-type'].toBe('application/json'))`.



## Resoluci√≥n de Errores

En la consola obtenemos un mensaje que nos dice que ha terminado el test pero tenemos cosas abiertas (por ejemplo el servidor). Adem√°s nos sugiere que agreguemos la opci√≥n `--detectOpenHandles`, hacemos esto por lo que el script nos queda:

```json
"test": "cross-env NODE_ENV=test jest --verbose --silent --detectOpenHandles"
```



Para cerrar el servidor primero lo almacenamos en `server` que luego exportamos:

```js
const server = app.listen('3000', () => console.log(`Listening on Port ${PORT}`));

module.exports = { app, server };
```



Luego en el test importamos el `server` y creamos un hook  `afterAll()` con un callback para que despu√©s de todos los tests y cierre la conexi√≥n del servidor.

```js
const { app, server } = require('../index');

// todos los tests
// ...

afterAll(() => {
    mongose.connection.close()
    server.close()
})
```



> Con la versi√≥n de mongoose `6.0.9` es posible tener problemas para ejecutar los tests y con `--detectOpenHandles` obten√≠a **Jest has detected the following 1 open handle potentially keeping Jest from exiting: ‚óè  Timeout**. Haciendo el downgrade a la versi√≥n `5.13.9` esto se soluciona.



Una vez solucionados todos los mensajes de la consola podemos sacar el `--detectOpenHandles`

```
"test": "cross-env NODE_ENV=test jest --verbose --silent"
```



## Watch Mode

Para no tener que correr el test manualmente con `npm run test` agregamos un nuevo script que se quedar√° atento a los cambios que hagamos en los archivos y volviendo a ejecutar los tests cuando estos sucedan:

`"test:watch": "cross-env NODE_ENV=test jest --verbose --silent --watch"`



O lo que es lo mismo reutilizando el script original de test:

```
"test:watch": "npm run test -- --watch"
```

> Hacemos referencia al script anterior y queremos pasarle m√°s par√°metros. Usamos `--` y luego `--watch` porque queremos pasarle el `--watch` al comando del script `test` y no al `npm run test`



Luego con `npm run test:watch` ejecutamos los tests y a partir del pr√≥ximo cambio se ejecutar√°n autom√°ticamente.



## `skip()`

Si queremos que no ejecuten una serie de tests moment√°neamente podemos hacer lo siguiente:

```js
describe.skip(()=> {
	test('...', () => {
		//...
	});
	
	test('...', () => {
		//...
	});
});
```



En caso de querer saltear un test individual tambi√©n podemos hacerlo con:

```js
test.skip('...', () => {
		//...
});
```

 

> Es posible configurar una **regla del linter** que muestre warning en caso de que salteemos tests.



## `only()`  

Si s√≥lo queremos correr un conjunto de tests podemos poner:

```
describe.only(()=> {
	test('...', () => {
		//...
	});
	
	test('...', () => {
		//...
	});
});
```

En caso de querer correr s√≥lo un test:

```
test.only('...', () => {
		//...
});
```



## Testear Archivo Espec√≠fico

En ocasiones **cuando estemos testeando un archivo y saltando los tests de otros archivos** puede resultar molesto ver en pantalla datos de los tests saltados. En esos casos podemos editar el script indicando expl√≠citamente el archivo que queremos testear:

```bash
"test": "jest --verbose --silent tests/notes.test.js"
```



Si queremos ir m√°s all√° y testear un archivo espec√≠fico y un test espec√≠fico podemos hacerlo con:

```
npm run test -- -t 'the first note should be about Juan'
```

> No es necesario poner el nombre completo podr√≠amos poner simplemente "juan" y en cualquier capitalizaci√≥n.



## Estado Inicial con `beforeEach`

Los tests deben ser **predecibles** de modo tal que siempre arrojen el mismo resultado. 

Primero verificamos que una ruta devuelve el **status code** y el **Content-Type** esperados. Sin embargo, si queremos verificar por ejemplo la cantidad de elementos devueltos por una ruta depender√≠amos de un factor externo como que alguien haya agregado un elemento a la base de datos de testing y as√≠ el test fallar√≠a.

Queremos tener la certeza de que el contenido de la base de datos es el esperado. Para ello antes de cada test borraremos todas las notas y luego agregaremos las de `initialNotes`. Esto lo hacemos utilizando el hook `beforeEach`

```js
const mongoose = require('mongoose');
const supertest = require('supertest');
const { app, server } = require('../index');
const Note = require('../models/Note');

const api = supertest(app);

const initialNotes = [
    {
        content: "Notas de Juan",
        important: true,
        date: new Date()
    },
    {
        content: "Nota de Paco",
        important: true,
        date: new Date()
    },
    {
        content: "Notas de Pedro",
        important: true,
        date: new Date()
    }
]

beforeEach(async () => {
    await Note.deleteMany({});

    const note1 = new Note(initialNotes[0])
    await note1.save()

    const note2 = new Note(initialNotes[1])
    await note2.save()

    const note3 = new Note(initialNotes[2])
    await note3.save()
})

describe('GET /api/notes', () => {
    test('there are three notes', async () => {
        const res = await api.get('/api/notes')
        expect(res.body).toHaveLength(initialNotes.length);
    });
})

afterAll(() => {
    server.close()
    mongoose.connection.close();
})
```

Tambi√©n podr√≠amos haber verificado que devuelva un array con 

```
expect(res.body).toBeInstanceOf(Array);
```



## Otras Peticiones `GET`

Si queremos testear que el contenido de un elemento en particular tenga ciertas caracter√≠sticas:

```js
test('the first note should be about Juan', async () => {
const res = await api.get('/api/notes');

expect(res.body[0].content).toBe('Notas de Juan');
});
```

Sin embargo, muchas veces queremos verificar el contenido en cualquier posici√≥n del array devuelto por la ruta:

```js
test('there should be a note about Paco', async () => {
    const res = await api.get('/api/notes');

    const contents = res.body.map(note => note.content);

    expect(contents).toContain('Notas de Paco');
});
```



## Peticiones `POST`

Cuando creamos una nota devolvemos un status code `201` que significa **created**.

```js
test('a new note should be added', async () => {
    const newNote = {
    	content: 'Notas de De La Mar',
    	important: false,
    };

    await api
    .post('/api/notes')
    .send(newNote)
    .expect(201)
    .expect('Content-Type', /application\/json/);

    const res = await api.get('/api/notes');

    const contents = res.body.map(note => note.content);

    expect(contents).toContain('Notas de De La Mar');
    expect(res.body).toHaveLength(initialNotes.length + 1);
});
```



Luego de agregar el elemento a la base de datos estamos chequeando tanto que el contenido sea el deseado como que el n√∫mero de elementos tambi√©n sea coherente.



Debemos chequear las condiciones de borde, por ejemplo que no sea posible agregar un elemento si falta un campo requerido. 

```js
test('an empty note should not be added', async () => {
    const newNote = {
    	important: false,
    };
    await api.post('/api/notes').send(newNote).expect(400);

    const res = await api.get('/api/notes');
    expect(res.body).toHaveLength(initialNotes.length);
});
```



> En este caso verificamos obtener un error 400 y que no hayan sido agregados elementos a la base de datos.

  ## Peticiones `DELETE`

Cuando eliminamos una nota devolvemos un status code `204` que significa **no content**.

Los tests los agrupamos dentro de este bloque:

```js
describe('DELETE /api/notes', () => {

})
```



Por ejemplo para testear el borrado de una nota.

Veremos mas adelante que `getAllNotes` es un helper para obtener las notas.

```js
test('a note should be deleted', async () => {
		const response = await getAllNotes()

		const { body: notes } = response;

		const [noteToDelete] = notes;

		await api
			.delete(`/api/notes/${noteToDelete.id}`)
			.expect(204)

		const response2 = await api.get('/api/notes');
		const content = response2.body.map(note => note.content)

		expect(response2.body).toHaveLength(initialNotes.length - 1)
		expect(contents).not.toContain(noteToDelete.content)
	})
```



> Estamos verificando que la cantidad de notas se reduce en una y que la nota que quisimos borrar no forma parte de las restantes.



Mientras que para testear que no se realiza el borrado si el ID es incorrecto:

```js
test('a note should not be deleted', async () => {
		await api
			.delete(`/api/notes/123`)
			.expect(400)

		const response = await api.get('/api/notes');

		expect(response.body).toHaveLength(initialNotes.length)
	})
```


## Test Helpers

Cuando tenemos l√≠neas de c√≥digo que se repiten es conveniente crear un archivo dentro de la carpeta `test` llamado `helpers.js` donde colocamos esas funciones o constantes requeridas.

Se recomienda **no utilizar helpers para el cuerpo del test** ya que aunque ese c√≥digo se repita nos ayudar√° a saber de d√≥nde viene el problema en lugar de tener una abstracci√≥n que lo har√≠a m√°s dificil.

Al implementar esto pondremos de manifiesto la importancia de los tests, ya que al refactorizar podremos tener certeza de que no hemos roto nada si seguimos pasando los tests.

Por ejemplo estas l√≠neas que usamos dos veces las convertimos en:

```js
const res = await api.get('/api/notes');
const content = res.body.map(note => note.content)
```



```js
const getAllContentFromNotes = async () => {
	const res = await api.get('/api/notes');
	return {
		res,
		contents: res.body.map(note => note.content)
	}
}
```

> Notar que en `getAllContentFromNotes` retornamos `res` y el array `contents` ya que necesitamos ambos para las comprobaciones que hacemos a continuaci√≥n.

Luego para usarlo `const {res, contents} = await getAllContentFromNotes()` .




Otra forma es implementando dos m√©todos:

```js
const getAllNotes = async () => {
	return api.get('/api/notes');
}

const getAllContentFromNotes = (notes) => {
	return notes.map(note => note.content)
}
```



Luego para utilizarlos:

```js
const response = await getAllNotes();
const contents = getAllContentFromNotes(response.body);
```



### Refactorizar `beforeEach()`

Hasta el momento tenemos 

```js
beforeEach(async () => {
	await Note.deleteMany({});

	const note1 = new Note(initialNotes[0]);
	await note1.save();

	const note2 = new Note(initialNotes[1]);
	await note2.save();

	const note3 = new Note(initialNotes[2]);
	await note3.save();
});
```



Esto mismo no podemos efectuarlo utilizando `forEach()` ya que no funciona de manera correcta con `async/await`. 

Tenemos dos alternativas

* Usar `forOf`

```js
beforeEach(async () => {
	await Note.deleteMany({});

	for(const note of initialNotes){
		const noteObject = new Note(note);
		await noteObject.save();
	}
});
```

Este m√©todo trabaja secuencialmente por lo que nos aseguramos que los elementos sean guardados en el mismo orden que est√°n en el array.

* Usando `map` y `Promise().all`

```js
beforeEach(async () => {
	await Note.deleteMany({});

	const notesObject = initialNotes.map(note => new Note(note))
	const promises = notesObject.map(noteObject => noteObject.save());
    await Promise.all(promises);
});
```

Este m√©todo tiene la ventaja que realiza el trabajo en paralelo y desventaja que puede que no incorpore  los elementos en orden.



## Tests de Administraci√≥n de Usuarios

Los modelos y controladores vinculados a la administraci√≥n de usuarios se ubican en el apartado **Administraci√≥n de Usuarios** en caso de dudas consultar ese material.



Creamos el archivo `user.test.js` y nos proponemos testear una ruta `POST` de creaci√≥n de usuarios . Para ello con `beforeEach` nos aseguramos borrar todos los usuarios y luego creamos uno y lo guardamos en la base de datos. 

En el test en s√≠ lo primero que hacemos es obtener todos los usuarios en un array (sabemos que deber√≠a haber s√≥lo uno pero de este modo lo dejamos prepado para si luego creamos m√°s en el `beforeEach`) y despu√©s agregamos un nuevo usuario y por √∫ltimo verificamos tener uno mas que al inicio.

Con `afterAll` nos aseguramos cerrar el servidor y la conexi√≥n de mongoose.

```js
const bcrypt = require('bcrypt')
const User = require('../models/User')
const { api, getUsers } = require('./helpers')
const moongose = require('mongoose')
const { server } = require('../index')

describe('creating a new user', () => {
    beforeEach(async () => {
        await User.deleteMany({})

        const passwordHash = await bcrypt.hash('pswd', 10)
        const user = new User({ username: 'jnmroot', passwordHash })

        await user.save()
    })

    test('should create a new user with a fresh username', async () => {
        const usersAtStart = await getUsers()

        const newUser = {
            username: 'midudev',
            name: 'Miguel',
            password: 'tw1tch'
        }

        await api
            .post('/api/users')
            .send(newUser)
            .expect(201)
            .expect('Content-Type', /application\/json/)

        const usersAtEnd = await getUsers()

        expect(usersAtEnd).toHaveLength(usersAtStart.length + 1)

        const usernames = usersAtEnd.map(u => u.username)
        expect(usernames).toContain(newUser.username)
    })


    afterAll(() => {
        moongose.connection.close()
        server.close()
    })
})
```



Inicialmente sabemos que deber√≠amos tener un √∫nico usuario dado que as√≠ lo hemos determinado en el `beforeEach`, no obstante verificamos esto con:

```js
const usersAtStart = await getUsers()
```



Siendo `getUsers()` un helper con el siguiente contenido:

```js
const getUsers = async () => {
	const usersDB = await User.find({})
	return usersDB.map(user => user.toJSON())
}
```

Notar que estamos trabajando con el modelo ya que a diferencia de cuando quer√≠amos todas las notas, no tenemos un endpoint para tal fin. Con `User.find({})` obtenemos los datos tal cual est√°n en la DB como un array de objetos que tienen `_id` y `__v` es por eso que con un map los sometemos a un `toJSON()`.



## Test Driven Development

TDD son las siglas de *test driven development* que es una forma de desarrollo en la cual primero se realiza el test y luego se crea el c√≥digo, esto nos permite desarrollar de manera m√°s fiable.

Existen distintas formas de trabajo: Una forma ser√≠a ir paso a paso desde el comienzo creando tests y luego desarrollando las funcionalidades y otra forma es plantear directamente un caso de uso. 

Por ejemplo siguiendo esta √∫ltima forma de trabajo, puede que queramos testear la condici√≥n de borde de qu√© sucede si intentamos crear un usuario cuyo `username` ya existe. La idea ser√≠a crear el test, que nos de rojo, luego desarrollar el c√≥digo hasta que no de verde y finalmente refactorizar.

```js
test('should not create user if username is already taken', async () => {
    const usersAtStart = await getUsers()

    const newUser = {
    username: 'miduroot',
    name: 'Miguel',
    password: 'midutest'
    }

    const result = await api
    .post('/api/users')
    .send(newUser)
    .expect(409)
    .expect('Content-Type', /application\/json/)

    console.log(result.body)

    expect(result.body.error).toContain('expected `username` to be unique')

    const usersAtEnd = await getUsers()
    expect(usersAtEnd).toHaveLength(usersAtStart.length)
})
```

Esperamos un 409 que significa **conflict**. Tambi√©n esperamos un `Content-Type` de `application/json` ya que vamos a querer enviar el error al cliente. A su vez tambi√©n chequeamos que el JSON devuelto tenga una propiedad `error` con el valor `expected username to be unique`



Por √∫ltimo con `usersAtEnd` buscamos verificar que no haya sido agregado el usuario a la base de datos a pesar de ya haber constatado todo lo anterior.

# Mocha

> Basado en [The Net Ninja - MondoDB Tutorial for Beginners](https://www.youtube.com/watch?v=9OPP_1eAENg&list=PL4cUxeGkcC9jpvoYriLI0bY8DOgWZfi6u)
> Basado en [Traversy Media - Intro To JavaScript Unit Testing With Mocha JS & Chai](https://www.youtube.com/watch?v=MLTRHc5dk6s)

## Introducci√≥n

Es el testing framework m√°s popular pero para ciertas tareas require del uso de librer√≠as como [Chai](https://www.chaijs.com/) y [Sinon](https://sinonjs.org/). Esto tiene la contra de tener que ver m√°s de una documentaci√≥n y dependiendo de la evoluci√≥n de estas bibliotecas en un futuro algo puede dejar de ser compatible con mocha.

Si queremos usar la assertion library default:
```js
const assert = require('assert');
```

Nos permite testear la conexi√≥n con la db, creaci√≥n, lectura, actualizaci√≥n y eliminaci√≥n de documentos en una colecci√≥n.

`npm install mocha`

```js
const assert = require('assert');

describe('demo test', () => {
	it('sumar dos n√∫meros', () => {
		assert(2 + 3 === 5);
	});
});
```

Dentro del bloque `describe()` colocamos los `it()` que consisten en tests individuales.

En `package.json` indicar a 
```json
"scripts": {
		"test": "mocha"
},
```
Luego al ejecutar `npm run test` (o la forma corta `npm test` o la a√∫n mas corta `npm t`) veremos un tilde verde indicando que el resultado del test fue exitoso.

Para llevar esto al siguiente nivel, vamos a trabajar con bases de datos para ello primero creamos un archivo en `/test/connection.js` donde realizamos la conexi√≥n con la base de datos.
```js
const mongoose = require('mongoose');
const MONGO_DB_URI = 'mongodb://localhost/unit-testing';

mongoose.connect(MONGO_DB_URI, {
	useNewUrlParser: true,
	useUnifiedTopology: true,
});

const db = mongoose.connection;
db.once('open', () => console.log('Conectado a MondoDB'));
db.on('error', (err) => console.log(err));
```

Luego creamos `/models/marioChar.js` donde creamos el modelo `MarioChar` que importaremos luego en los tests.

```js
const mongoose = require('mongoose');

const mariocharSchema = new mongoose.Schema({
	name: {
		type: String,
		required: true,
		min: 3,
		max: 50,
	},
	weight: {
		type: Number,
	},
});

const Mariochar = mongoose.model('Mariochar', mariocharSchema);

module.exports = Mariochar;
```

Creamos el archivo `/test/saving_test.js`

```js
const assert = require('assert');
const Mariochar = require('../models/mariochar');

describe('Creacion Documentos', () => {
	it('Save', () => {
		const char = new Mariochar({
			name: 'Mario',
			weight: 80,
		});
		char.save().then(() => {
			assert(!char.isNew);
			done();
		});
	});
});
```

`char.isNew` es true cuando el objeto fue creado localmente pero no fue guardado en la base de datos.
`done()` lo utilizamos cuando hay operaciones asincr√≥nicas, ya que necesito un modo de indicarle a mocha que ha terminado el test y podemos pasar al siguiente.

## Hooks 
Cuando ejecutamos `node run test` vemos lo siguiente:
```bash
	Creacion Documentos
Conectado a MondoDB
	    ‚àö Save
```
Esto significa que antes de conectarse a la base de datos comenz√≥ a realizar el test "Creaci√≥n documentos" 
Utilizando mocha hooks podremos establecer el c√≥digo que queremos ejecutar antes o despu√©s de un test. En este caso queremos ejecutar el c√≥digo que realiza la conexi√≥n antes de los tests. 
Por lo tanto en `connection.js`:
```js
before((done) => {
	mongoose.connect(dbURI, {
		useNewUrlParser: true,
		useUnifiedTopology: true,
	});

	const db = mongoose.connection;
	db.once('open', () => {
		console.log('Conectado a MondoDB');
		done();
	});
	db.on('error', (err) => console.log(err));
});

```

Haciendo uso de los mocha hooks tambi√©n podremos por ejemplo eliminar toda la colecci√≥n antes de ejecutar cada testeo, por lo que en `connection.js` agregamos:
```js
beforeEach((done) => {
	mongoose.connection.collections.mariochars.drop(() => {
		done();
	});
});
```

Notar que es en el √∫nico lugar al que nos referimos a `mariochars` en plural ya que as√≠ se llama la colecci√≥n.

## Encontrar Documentos
Creamos el archivo `/test/finding_test.js` y como en `connection.js` eliminamos todos los documentos de la colecci√≥n antes de cada test, debemos crear un nuevo documento para luego buscarlo.
Para asegurarnos que el documento haya sido creado antes de buscarlo utilizamos el hook `beforeEach()`

```js
const assert = require('assert');
const Mariochar = require('../models/mariochar');

describe('Busqueda Documentos', () => {
	//Creacion de documento
	beforeEach((done) => {
		const char = new Mariochar({ name: 'Mario' });
		char.save().then(() => done());
	});

	//Lectura documento
	it('find', (done) => {
		Mariochar.findOne({ name: 'Mario' }).then((result) =>
			assert(result.name === 'Mario')
		);
		done();
	});
});

```
En este caso `findOne()` buscar√° al primer elemento con `name:'Mario'`. Supongamos por un momento que tenemos m√°s de un elemento con el mismo nombre en ese caso vamos a querer buscar al que acabamos de crear y eso lo hacemos filtrando de acuerdo a su `_id` con el m√©todo findById. Para eso agregamos un nuevo test debajo del anterior:
```js
const assert = require('assert');
const Mariochar = require('../models/mariochar');

describe('Busqueda Documentos', () => {
	let myChar;
	//Creacion de documento
	beforeEach((done) => {
		const char = new Mariochar({ name: 'Mario' });
		myChar = char;
		char.save().then(() => done());
	});

	//Lectura documento
	it('find', (done) => {
		Mariochar.findOne({ name: 'Mario' }).then((result) =>
			assert(result.name === 'Mario')
		);
		done();
	});
	//Lectura documento por id
	it('find by id', (done) => {
		Mariochar.findOne({ _id: myChar._id }).then((result) =>
			assert(result._id.toString() === myChar._id.toString())
		);
		done();
	});
});

```
Debemos tener presente que `_id` no es un string sino un objeto por lo que para comparar si el valor le√≠do es igual al esperado debemos convertir ambos a string tal como vemos en: `result._id.toString() === myChar._id.toString()`

## Eliminar Documentos:
A continuaci√≥n creamos un archivo `/test/deleting_test.js` y primero vamos a crear un documento, luego lo eliminamos con `findOneAndRemove()` y por √∫ltimo con `findOne()` lo buscamos y hacemos llamamos a assert indicando que el resultado correcto es `null`.
```js
const assert = require('assert');
const Mariochar = require('../models/mariochar');

describe('Eliminacion Documentos', () => {
	//Creacion de documento
	beforeEach((done) => {
		const char = new Mariochar({ name: 'Mario' });
		char.save().then(() => done());
	});
	//Eliminacion de documento
	it('findOneAndRemove', (done) => {
		Mariochar.findOneAndRemove({ name: 'Mario' }).then(() => {
			Mariochar.findOne({ name: 'Mario' }).then((result) => {
				assert(!result);
				done();
			});
		});
	});
});

```

Para evitar el *DeprecationWarning* al usar findOneAndRemove() debemos agregar al options object de la conexi√≥n `useFindAndModify: false`


## Actualizar Documentos:
El modo de trabajo ser√° similar al anterior primero creamos un nuevo test donde agregamos un nuevo documento, usamos `findOneAndUpdate()` para cambiar el nombre, hacemos `findOne()` para buscar el elemento reci√©n actualizado de acuerdo a su `_id` y `assert()` con la propiedad modificada.

```js
const assert = require('assert');
const Mariochar = require('../models/mariochar');

describe('Actualizar Documento', () => {
	let char;
	//Creacion de documento
	beforeEach((done) => {
		char = new Mariochar({ name: 'Mario' });
		char.save().then(() => done());
	});

	//Actualizaci√≥n documento
	it('findOneAndUpdate', (done) => {
		Mariochar.findOneAndUpdate({ name: 'Mario' }, { name: 'Luigi' })
			.then(() => Mariochar.findOne({ _id: char._id }))
			.then((result) => {
				assert(result.name === 'Luigi');
				done();
			});
	});
});
```

## Actualizar Documento con Update Operators
De manera similar a lo realizado en el apartado anterior, creamos un nuevo personaje al cual le asignamos nombre y peso, a continuaci√≥n con `updateOne()` y el uso de *update operators* incrementamos su peso en una unidad, luego lo buscamos por `_id` y llamamos a `assert()` con el nuevo peso esperado.
```js
const assert = require('assert');
const Mariochar = require('../models/mariochar');

describe('Incrementar Documento', () => {
	let char;
	//Creacion de documento
	beforeEach((done) => {
		char = new Mariochar({ name: 'Mario', weight: 50 });
		char.save().then(() => done());
	});

	//Actualizaci√≥n documento
	it('updateOne', (done) => {
		Mariochar.updateOne({ name: 'Mario' }, { $inc: { weight: 1 } })
			.then(() => Mariochar.findOne({ _id: char._id }))
			.then((result) => {
				assert(result.weight === 51);
				done();
			});
	});
});

```

En caso de querer actualizar m√°s de un documento podr√≠amos usar `updateMany()` en lugar de `updateOne()`:

```js
//Actualizaci√≥n documento
	it('updateOne', (done) => {
		Mariochar.updateMany({}, { $inc: { weight: 1 } })
			.then(() => Mariochar.findOne({ _id: char._id }))
			.then((result) => {
				assert(result.weight === 51);
				done();
			});
	});
```

## Documentos Anidados
Queremos crear una colecci√≥n `authors` que cuente con las propiedades `name (String)`, `age (Number)` y a su vez `books` que ser√° de tipo `[bookSchema]`.
La colecci√≥n `books`  en tanto deber√° contar con las propiedades `title`, `pages`.

Creamos el archivo `/models/author.js`

```js
const mongoose = require('mongoose');

const BookSchema = new mongoose.Schema({
	title: String,
	pages: Number,
});

const AuthorSchema = new mongoose.Schema({
	name: String,
	books: [BookSchema],
});

const Author = mongoose.model('author', AuthorSchema);

module.exports = Author;
```

Luego en `nesting_test.js` el proceso es similar al que venimos trabajando. Tenemos dos tests y antes de cada uno de ellos vamos a vaciar la colecci√≥n `authors`.
El primer test consiste en crear un nuevo autor, guardarlo en la base de datos y luego buscar un autor con ese nombre y llamar a `assert()` preguntando si la cantidad de elementos del array `books` es 1.
En el segundo test nuevamente creamos un autor, lo guardamos y a continuaci√≥n agregamos un nuevo libro al array `books`, luego lo buscamos (por el nombre del autor) y preguntamos si la cantidad de elementos del array `books` es 2.

```js
const assert = require('assert');
const mongoose = require('mongoose');
const Author = require('../models/author');

// Describe our tests
describe('Documentos Anidados', () => {
	beforeEach((done) => {
		// Drop the collection
		mongoose.connection.collections.authors.drop(() => {
			done();
		});
	});

	// Create tests
	it('Creates an author with sub-documents', (done) => {
		var pat = new Author({
			name: 'Patrick Rothfuss',
			books: [{ title: 'Name of the Wind', pages: 400 }],
		});-

		pat.save().then(() => {
			Author.findOne({ name: 'Patrick Rothfuss' }).then(function (record) {
				assert(record.books.length === 1);
				done();
			});
		});
	});

	it('Adds a book to an author', (done) => {
		var pat = new Author({
			name: 'Patrick Rothfuss',
			books: [{ title: 'Name of the Wind', pages: 400 }],
		});

		pat.save().then(() => {
			Author.findOne({ name: 'Patrick Rothfuss' }).then(function (record) {
				// add a book to the books collection
				record.books.push({ title: "Wise Man's Fear", pages: 500 });
				record.save().then(() => {
					Author.findOne({ name: 'Patrick Rothfuss' }).then(function (record) {
						assert(record.books.length === 2);
						done();
					});
				});
			});
		});
	});
});
```
