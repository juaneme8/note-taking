>  :link: Basado en el [tutorial de Odyssey](https://www.apollographql.com/tutorials/lift-off-part1) la academia de Apollo



Haremos un fetch server side para mostrar una serie de cards con informaci칩n sobre learning tracks. Un track es un conjunto de m칩dulos que ense침a sobre un tema espec칤fico. A su vez cada track tendr치 un autor y ese mismo autor podr치 tener a su cargo la creaci칩n de varios tracks.



## Schema-first

La implementaci칩n schema-first consta de los siguientes pasos:

1. Definir el schema. Determinar los datos necesarios para la funcionalidad.
2. Implementar el Backend con una GraphQL API utilizando Apollo Server y hacer el fetch los datos (que en principio ser치n mockedos y luego conectarla a una fuente de datos REST).

3) Implementar el frontend. Consumir los datos de la GraphQL API para renderizar las vistas.

Esta implemenetaci칩n nos permitir치 a los equipos de FE y BE trabajar de manera simult치nea con lo cual reduciremos el tiempo de desarrollo. Una vez definido el schema los de FE podr치n comenzar a trabajar con la data mockeada mientras los de BE desarrollan la GraphQL API conforme a ese mismo schema.



## Definir schema

Lo primero que debemos hacer es pensar qu칠 datos necesitamos para nuestra funcionalidad. En nuestro caso para cada card vamos a querer mostrar:

* `title`
* `thumbnail`
* `length`
* `module_count`
* `author_name`
* `author_picture`



Si bien podr칤amos crear un 칰nico tipo y colocar en el todos los campos, esto podr칤a ocasionar duplicaci칩n de datos (ya que un autor podr칤a crear mas de un track). Es por eso  que utilizaremos dos tipos `track` y `author`.

Podemos pensar en los datos de la aplicaci칩n como una colecci칩n de objetos (learning tracks y autores). Nuestra data puede ser representada mediante nodos (representando objetos) y aristas (representando relaciones entre estos objetos).

<img src="2 Intro 2024.assets/LO_02_v2.00_04_53_09.Still002_g8xow6_bbgabz.jpg" alt="A doodle of a graph, consisting of nodes with relationships to other nodes" style="zoom: 33%;" />

El schema es el contrato entre el servidor y el cliente que define lo que la GraphQL API puede hacer y c칩mo deben ser solicitados o modificados los datos a la vez que oculta detalles de la implementaci칩n del servicio.



##  Schema Definition Language (SDL)

Un schema es una colecci칩n de object types que contienen fields, cada campo o field tiene un tipo o type que puede ser escalar (`Int`, `Float`, `String`, `Boolean`, `ID`) o un objeto que contiene campos propios.

Podemos declarar un type utilizando la keyword `type` utilizando PascalCase

```
type SpaceCat {
  age: Int!
  missions: [Mission]
}
```

* Los nombres de los campos los declaramos utilizando camelCase.

* Con los corchetes indicamos que se trata de una lista.
* Los campos no se separan por comas.
* Con un signo de exclamaci칩n despu칠s del tipo indicamos que no puede ser nulo ese campo.



## Documentaci칩n

Es una buena pr치ctica documentar los schemas, esto no s칩lo simplificar치 nuestro trabajo y el de nuestros colegas sino que podr치 integrarse con herramientas como Apollo Studio Explorer para tener noci칩n de lo que puede realizarse con la API.

Podemos documentar tanto types como campos utilizando comillas dobles directamente en la l칤nea arriba de ellos:

```
"I'm a regular description"
```

Si queremos utilizar comentarios mas largos y multi-l칤nea debemos utilizar triple doble comillas:

```
"""
I'm a block description
with a line break
"""
```



# Servidor

Creamos un directorio `server` y luego inicializamos el proyecto de node con:

```
npm init -y
```



## Dependencias

* `@apollo/server` proporciona una implementaci칩n completa de un servidor de graphql
* `graphql` proporciona la l칩gica para parsear y validar las queries de graphql.
* `graphql-tag` proporciona utilidades para parsear queries de graphql: `gql` es una template literal tag.

Creamos el archivo `schema.js`



```
npm install @apollo/server graphql graphql-tag
```



## Dependencias Desarrollo

```
npm i -D typescript ts-node-dev nodemon
```



## Setup TypeScript

Creaci칩n de `tsconfig.json` bas치ndonos en el repo de Apollo

```
{
  "compilerOptions": {
    "rootDir": "src",
    "outDir": "dist",
    "target": "es2020",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "module": "commonjs"
  },
  "include": ["src"]
}
```



En `package.json` agregamos los scripts que utilizaremos:

```json
"scripts": {
    "compile": "tsc",
  	"dev": "ts-node-dev --respawn ./src/index.ts",
  	"start": "npm run compile && nodemon ./dist/index.js"
}
```

> Basado en el [repositorio de apollographql](https://github.com/apollographql/odyssey-lift-off-part1/blob/typescript/server/package.json)



## Schema

Creamos un directorio `src` y dentro de el un archivo `schema.js`



```js
const gql = require('graphql-tag');
```



`gql` es un template string tag para envolver strings de GraphQL y convertirlos en la forma que Apollo espera y a su vez posibilitar el sintax highlighting.



```js
const gql = require('graphql-tag');

const typeDefs = gql`

`;

module.exports = typeDefs.
```



Otra forma de escribir lo mismo utilizando imports.

```js
import gql from "graphql-tag";
 
export const typeDefs = gql`
`;
```



Crearemos los types `Track` y `Author`. 

```js
"A track is a group of Modules that teaches about a specific topic"
type Track {
  id: ID!
  title: String!
  author: Author!
  thumbnail: String
  length: Int
  modulesCount: Int
}
```



```js
"Author of a complete Track or a Module"
type Author {
  id: ID!
  name: String!
  photo: String
}
```



Luego queremos crear el `type Query` con el campo `tracksForHome` que devolver치 un listado con todos los tracks disponibles.

```js
type Query {
  "Get tracks array for homepage grid"
  tracksForHome: [Track!]!
}
```



El archivo completo nos queda:

```js
import gql from "graphql-tag";
 
export const typeDefs = gql`
  type Query {
    "Get tracks array for homepage grid"
    tracksForHome: [Track!]!
  }
   
  "A track is a group of Modules that teaches about a specific topic"
  type Track {
    id: ID!
    "The track's title"
    title: String!
    "The track's main author"
    author: Author!
    "The track's main illustration to display in track card or track page detail"
    thumbnail: String
    "The track's approximate length to complete, in minutes"
    length: Int
    "The number of modules this track contains"
    modulesCount: Int
  }
   
  "Author of a complete Track"
  type Author {
    id: ID!
    "Author's first and last name"
    name: String!
    "Author's profile picture url"
    photo: String
  }
`;
```



El objetivo del backend es crear un servidor de GraphQL debemos procesar las GraphQL queries del cliente, validarlas contra el schema,  popular los campos del schema solicitados con la data mockeada y retornar esto como respuesta. Si bien podemos hacerlo manualmente, Apollo Server acelera este proceso y lo hace listo para producci칩n. 



## Creaci칩n server

Creamos el archivo `index.ts` en `src`.

```js
import { ApolloServer } from "@apollo/server";
import { startStandaloneServer } from "@apollo/server/standalone";
import { typeDefs } from "./schema";

async function startApolloServer() {
  const server = new ApolloServer({ typeDefs });
  const { url } = await startStandaloneServer(server);

  console.log(`
    游  Server is running!
    游닔  Query at ${url}
  `);
}

startApolloServer();
```

:rotating_light: Observar que importamos `schema` sin el `.ts` porque el c칩digo compilado importar치 un archivo `.js` y como actualmente no tenemos ese `schema.js` omitimos la extensi칩n y TypeScript se encargar치 de hacerlo cuando compile el c칩digo.



Ejecutamos ahora:

```
npm run dev
```

Hasta el momento no tenemos conectado nuestro servidor a ninguna fuente de datos, pero contamos con herramientas que nos permiten testear las queries y obtener una respuesta v치lida.



## Mocking data

Es posible testear las queries aun sin contar con datos reales utilizando data mockeada y los type definitions creados anteriormente.

Para acceder a estas herramientas debemos instalar dos paquetes:

```
npm install @graphql-tools/mock @graphql-tools/schema
```



Lo primero que hacemos es trabajar con estos dos paquetes importando `addMocksToSchema` y `makeExecutableSchema`

```
import { addMocksToSchema } from "@graphql-tools/mock";
import { makeExecutableSchema } from "@graphql-tools/schema";
```



Luego  modificamos la inicializaci칩n de `ApolloServer`, que hasta ahora era:

```
const server = new ApolloServer({ typeDefs });
```



Lo convertimos en:

```
const server = new ApolloServer({
  schema: addMocksToSchema({
    schema: makeExecutableSchema({ typeDefs }),
  }),
});
```

Con este c칩digo generamos un schema ejecutable basado en `typeDefs` y le indicamos a Apollo que debe popular cada campo con un placeholder (por ejemplo en el caso de String entregar치 Hello World).

Si ahora ingresamos a Apollo Explorer en http://localhost:4000/ podremos usar Apollo Sandbox que es un modo para desarrollo en el cual podemos usar los cambios locales antes de deployarlos. y cargamos:

```
query ExampleQuery {
  tracksForHome {
    title
  }
}
```

Nos devolver치 data mockeada acorde a lo esperado.



Para ir un paso mas all치 creamos el objeto `mocks` para obtener datos realistas para el t칤tulo de un track o la URL de la foto de un autor.

```js
const mocks = {
  Track: () => ({
    id: () => "track_01",
    title: () => "Astro Kitty, Space Explorer",
    author: () => {
      return {
        name: "Grumpy Cat",
        photo:
          "https://res.cloudinary.com/dety84pbu/image/upload/v1606816219/kitty-veyron-sm_mctf3c.jpg",
      };
    },
    thumbnail: () =>
      "https://res.cloudinary.com/dety84pbu/image/upload/v1598465568/nebula_cat_djkt9r.jpg",
    length: () => 1210,
    modulesCount: () => 6,
  }),
};
```



Luego se lo pasamos al constructor `ApolloServer`

```js
const server = new ApolloServer({
  schema: addMocksToSchema({
    schema: makeExecutableSchema({ typeDefs }),
    mocks,
  }),
});
```



Luego al ingresar a Apollo Server en el navegador obtendremos exactamente dos resultados con la misma data. Si queremos obtener m치s debemos modificar `Query.tracksForHome` en `mocks`.

```js
const mocks = {
  Query: () => ({
    tracksForHome: () => [...new Array(6)],
  }),
  Track: () => ({
    ...
  }),
};
```

